#pragma once

#include <Storages/MergeTree/MergeTreeData.h>
#include <AggregateFunctions/AggregateFunctionGroupBitmap.h>

namespace DB
{

using RoaringBitmap = RoaringBitmapWithSmallSet<UInt32, 255>;
using RoaringBitmapPtr = std::shared_ptr<RoaringBitmap>;

class MergeTreeDataUniquer;

/**
 * Copy on write
 * PartBitmap::Ptr  read-only pointer
 * PartBitmap::MutablePtr   writable pointer
 *
 * The Part generated by UniqueMergeTree corresponds to a PartBitmap, which saves the index of the unique_key_id and persists it to the file.
 */
class PartBitmap : public COW<PartBitmap>
{
private:
    friend class COW<PartBitmap>;
    friend class PartBitmap;
    friend class MergeTreeDataUniquer;
    friend class MergeTreePartitionUniquer;

    PartBitmap() = default;

    explicit  PartBitmap(int64_t seq_id_)
        : PartBitmap(std::make_shared<RoaringBitmap>(), seq_id_, seq_id_)
    {}

    PartBitmap(int64_t seq_id_, int64_t update_seq_id_)
        : PartBitmap(std::make_shared<RoaringBitmap>(), seq_id_, update_seq_id_)
    {}

    PartBitmap(RoaringBitmapPtr bitmap_, int64_t seq_id_, int64_t update_seq_id_)
        : bitmap(bitmap_)
        , seq_id(seq_id_)
        , update_seq_id(update_seq_id_)
    {}

    virtual PartBitmap::MutablePtr clone() const;

public:
    virtual ~PartBitmap() = default;

    int64_t getSeqId() const { return seq_id; }
    int64_t getUpdateSeqId() const { return update_seq_id; }

    void setSeqId(int64_t id) { seq_id = id; }
    void setUpdateSeqId(int64_t id) { update_seq_id = id; }

    /// Serialize bitmap to disk, located in the subdirectory of part
    void serialize(MutableDataPartStoragePtr data_part_storage);
    /// Deserialize bitmap from disk, only once
    void deserialize(MutableDataPartStoragePtr data_part_storage);

    /// Add an id to bitmap
    void insert(UInt32 unique_id) { bitmap->add(unique_id); }
    /// Check if id exists through bitmap index
    bool contains(UInt32 id) const { return bitmap->rb_contains(id); }
    /// bitmap union
    void bitmapOR(RoaringBitmapPtr bitmap_ptr) { bitmap->rb_or(*bitmap_ptr); }
    void bitmapOR(PartBitmap::Ptr part_bitmap) { bitmap->rb_or(*(part_bitmap->bitmap)); }
    /// Calculate the intersection and then negate
    void bitmapAndNot(RoaringBitmapPtr bitmap_ptr) { bitmap->rb_andnot(*bitmap_ptr); }

    String toString() const;
private:
    RoaringBitmapPtr bitmap;
    int64_t seq_id;
    int64_t update_seq_id;
};

using PartBitmaps = std::vector<PartBitmap::Ptr>;

struct PartBitmapGuard : private boost::noncopyable
{
    struct Lock : public std::unique_lock<std::mutex>
    {
        Lock() = default;
        explicit Lock(std::mutex & mutex_) : std::unique_lock<std::mutex>(mutex_) {}
    };

    Lock lock() { return Lock(mutex); }
    std::mutex mutex;
};


struct PartBitmapEntry : private boost::noncopyable
{
    friend class MergeTreeDataUniquer;
public:
    PartBitmapEntry(const MergeTreeDataPartPtr & data_part)
    : part(data_part)
    , part_name(data_part->name)
    {}

    ~PartBitmapEntry()
    {
        part.reset();
        part_bitmap = nullptr;
    }

    PartBitmap::Ptr getPartBitmap();
    void setPartBitmap(PartBitmap::MutablePtr new_part_bitmap);

    PartBitmapGuard::Lock lockPartBitmap() { return guard.lock(); }

private:
    MergeTreeDataPartPtr getDataPart();

    std::weak_ptr<const IMergeTreeDataPart> part;
    String part_name;
    PartBitmapGuard guard;
    PartBitmap::Ptr part_bitmap = nullptr;
};

using PartBitmapEntryPtr = std::shared_ptr<PartBitmapEntry>;


class PartBitmapCache : public std::unordered_map<String, PartBitmapEntryPtr>, private boost::noncopyable
{
public:
    PartBitmapEntryPtr getPartBitmapEntry(const MergeTreeDataPartPtr & data_part);
    PartBitmap::Ptr getPartBitmap(const MergeTreeDataPartPtr & data_part);

    void removePartBitmap(const MergeTreeDataPartPtr & data_part);
    void setPartBitmap(const MergeTreeDataPartPtr & data_part, PartBitmap::MutablePtr new_part_bitmap);
private:
    std::mutex mutex;
};


}
